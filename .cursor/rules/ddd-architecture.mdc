---
description: DDD layered architecture rules - enforce layer dependency boundaries and team ownership
alwaysApply: true
---

# DDD Architecture Rules

## Layer Dependencies (STRICTLY enforced)

```
API Layer → Application Layer → Domain Layer
                  ↓
          Infrastructure Layer
```

- **Domain Layer**: ZERO external imports. No FastAPI, SQLAlchemy, or any framework. Pure Python only.
- **Application Layer**: Imports from Domain only. Uses interfaces (not implementations). Orchestrates use cases.
- **Infrastructure Layer**: Implements Domain interfaces. May import external libraries.
- **API Layer**: Imports from Application only. Uses DTOs, never domain entities directly.

## Bounded Contexts and Ownership

| Context | Owner | Directory |
|---------|-------|-----------|
| `optimization/` | **Person A** (AI Workflow) | LangGraph agents, RAG, ATS scoring |
| `interview/` | **Person A** (AI Workflow) | Question generator, cover letter |
| `identity/` | **Person B** (Platform) | Auth, JWT, tenants, users |
| `resume/` | **Person B** (Platform) | PDF upload, parsing, vector store |
| `billing/` | **Person B** (Platform) | Subscriptions, quotas, usage |
| `shared/` | **Both** | Base classes, middleware — changes need both owners |
| `frontend/` | **Person B** (Platform) | All frontend code |

Each context has: `domain/`, `application/`, `infrastructure/`, `api/`.
CODEOWNERS file enforces review by the correct owner.

## Key Patterns

- **Repository**: All data access via interfaces (defined in domain, implemented in infra)
- **Factory**: Use for aggregate/entity creation with validation
- **Unit of Work**: Wrap write operations for transactional consistency
- **Strategy**: LLM providers, PDF parsers — runtime selection via interface
- **Template Method**: AI agents inherit `BaseAgent` with `prepare → execute → parse_output`
- **Adapter**: Wrap external APIs (ChromaDB, S3, Stripe) in adapter classes
- **Dependency Injection**: Use FastAPI `Depends()` — never instantiate dependencies internally

## Anti-Patterns to AVOID

- **Anemic Domain Model**: entities with no behavior — put logic IN entities
- **God Service**: one class doing everything — split by bounded context
- **Leaky Abstraction**: SQLAlchemy models used as domain entities — keep them separate
- **Shared Mutable State**: use `ContextVar` for request-scoped state, DI for dependencies
- **Cross-context coupling**: contexts communicate via domain events, not direct imports

## How to defined DDD in code?
Can't you write the basic logic in a pure Python file without importing any third-party libraries (SQLAlchemy, FastAPI, Redis, JOSE, etc.)?

- Yes → Domain Layer
- No → Infrastructure Layer
- If the code itself doesn't contain "rules" and only coordinates between calling parties → Application Layer
- If the code only performs HTTP request/response transformations → API Layer